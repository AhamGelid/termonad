
module Main where

import Termonad.Prelude

import Hedgehog
  ( Command(Command)
  , Concrete
  , HTraversable(htraverse)
  , MonadTest
  , Property
  , Symbolic
  , annotate
  , executeSequential
  , failure
  , forAll
  , property
  )
import Hedgehog.Gen (sequential)
import Hedgehog.Range (linear)
import Test.Tasty (TestTree, defaultMain, testGroup)
import Test.Tasty.Hedgehog (testProperty)

import Termonad.FocusList (FocusList, emptyFL, insertFL)

main :: IO ()
main = do
  tests <- testsIO
  defaultMain tests

testsIO :: IO TestTree
testsIO = do
  pure $
    testGroup
      "tests"
      [ testProperty "foo" foo
      ]

foo :: Property
foo =
  property $ do
    actions <-
      forAll $
        sequential
          (linear 1 100)
          initialState
          [ insertFLCommand ]
    executeSequential initialState actions

-- property :: HasCallStack => PropertyT IO () -> Property

-- forAll :: (Monad m, Show a) => Gen a -> PropertyT m a
-- sequential :: (MonadGen n, MonadTest m) => Range Int -> (forall v. state v) -> [Command n m state] -> n (Sequential m state)

-- executeSequential :: (MonadTest m, MonadCatch m) => (forall v. state v) -> Sequential m state -> m ()


-- data Command n m (state :: (* -> *) -> *) =
--   forall input output.
--   (HTraversable input, Show (input Symbolic), Typeable output) =>
--   Command {
--     -- | A generator which provides random arguments for a command. If the
--     --   command cannot be executed in the current state, it should return
--     --   'Nothing'.
--     --
--       commandGen ::
--         state Symbolic -> Maybe (n (input Symbolic))
--
--     -- | Executes a command using the arguments generated by 'commandGen'.
--     --
--     , commandExecute ::
--         input Concrete -> m output
--
--     -- | A set of callbacks which provide optional command configuration such
--     --   as pre-condtions, post-conditions and state updates.
--     --
--     , commandCallbacks ::
--         [Callback input output state]
--     }

data State a (v :: k) = State { unState :: FocusList a } deriving (Eq, Show)

initialState :: State a v
initialState = State emptyFL

data InsertFL a v = InsertFL { unInsertFL :: FocusList a } deriving (Eq, Show)

instance HTraversable (InsertFL x) where
  htraverse :: forall f g h. Applicative f => (forall a. g a -> f (h a)) -> InsertFL x g -> f (InsertFL x h)
  htraverse func (InsertFL x) = pure (InsertFL x)

insertFLCommand :: forall n m. (Monad n, MonadTest m) => Command n m (State String)
insertFLCommand = Command generator execute []
  where
    generator :: State String Symbolic -> Maybe (n (InsertFL String Symbolic))
    generator (State fl) = Just $ pure (InsertFL fl)

    execute :: InsertFL String Concrete -> m (FocusList String)
    execute (InsertFL fl) =
      case insertFL 0 "hello" fl of
        Nothing -> do
          annotate "Failed to insert a value into the FocusList"
          failure
        Just newFL -> pure newFL
