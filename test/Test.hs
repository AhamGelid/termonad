{-# LANGUAGE InstanceSigs #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Main where

import Hedgehog (Command(Command), Concrete, HTraversable(htraverse), Property, Symbolic, executeSequential, forAll, property)
import Hedgehog.Gen (sequential)
import Hedgehog.Range (linear)
import Test.Tasty (TestTree, defaultMain, testGroup)
import Test.Tasty.Hedgehog (testProperty)

import Termonad.FocusList (FocusList, emptyFL)

main :: IO ()
main = do
  tests <- testsIO
  defaultMain tests

testsIO :: IO TestTree
testsIO = do
  pure $
    testGroup
      "tests"
      [ testProperty "foo" foo
      ]

foo :: Property
foo =
  property $ do
    actions <-
      forAll $
        sequential
          (linear 1 100)
          initialState
          [ insertFLCommand ]
    executeSequential initialState actions

-- property :: HasCallStack => PropertyT IO () -> Property

-- forAll :: (Monad m, Show a) => Gen a -> PropertyT m a
-- sequential :: (MonadGen n, MonadTest m) => Range Int -> (forall v. state v) -> [Command n m state] -> n (Sequential m state)

-- executeSequential :: (MonadTest m, MonadCatch m) => (forall v. state v) -> Sequential m state -> m ()


-- data Command n m (state :: (* -> *) -> *) =
--   forall input output.
--   (HTraversable input, Show (input Symbolic), Typeable output) =>
--   Command {
--     -- | A generator which provides random arguments for a command. If the
--     --   command cannot be executed in the current state, it should return
--     --   'Nothing'.
--     --
--       commandGen ::
--         state Symbolic -> Maybe (n (input Symbolic))
--
--     -- | Executes a command using the arguments generated by 'commandGen'.
--     --
--     , commandExecute ::
--         input Concrete -> m output
--
--     -- | A set of callbacks which provide optional command configuration such
--     --   as pre-condtions, post-conditions and state updates.
--     --
--     , commandCallbacks ::
--         [Callback input output state]
--     }

data State a (v :: k) = State { unState :: FocusList a } deriving (Eq, Show)

initialState :: State a v
initialState = State emptyFL

data InsertFL v = InsertFL deriving (Eq, Show)

instance HTraversable InsertFL where
  htraverse :: forall f g h. Applicative f => (forall a. g a -> f (h a)) -> InsertFL g -> f (InsertFL h)
  htraverse func InsertFL = pure InsertFL

insertFLCommand :: forall n m. (Monad n, Monad m) => Command n m (State String)
insertFLCommand = Command generator execute undefined
  where
    generator :: State String Symbolic -> Maybe (n (InsertFL Symbolic))
    generator _curState = Just $ pure InsertFL

    execute :: InsertFL Concrete -> m ()
    execute InsertFL = undefined
