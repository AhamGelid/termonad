
module Main where

import Termonad.Prelude hiding (assert)

import Control.Lens ((^.))
import Hedgehog
  ( Callback(Ensure, Update)
  , Command(Command)
  , Concrete(Concrete)
  , HTraversable(htraverse)
  , MonadGen
  , MonadTest
  , Property
  , Symbolic
  , Test
  , Var(Var)
  , (===)
  , annotate
  , assert
  , executeSequential
  , failure
  , forAll
  , property
  )
import Hedgehog.Gen (ascii, int, sequential, string)
import Hedgehog.Range (linear)
import Test.Tasty (TestTree, defaultMain, testGroup)
import Test.Tasty.Hedgehog (testProperty)

import Termonad.FocusList (FocusList, emptyFL, insertFL, invariantFL, lensFocusListLen, lookupFL)

main :: IO ()
main = do
  tests <- testsIO
  defaultMain tests

testsIO :: IO TestTree
testsIO = do
  pure $
    testGroup
      "tests"
      [ testProperty "foo" foo
      ]

foo :: Property
foo =
  property $ do
    actions <-
      forAll $
        sequential
          (linear 1 100)
          initialState
          [ insertFLCommand ]
    executeSequential initialState actions

-- property :: HasCallStack => PropertyT IO () -> Property

-- forAll :: (Monad m, Show a) => Gen a -> PropertyT m a
-- sequential :: (MonadGen n, MonadTest m) => Range Int -> (forall v. state v) -> [Command n m state] -> n (Sequential m state)

-- executeSequential :: (MonadTest m, MonadCatch m) => (forall v. state v) -> Sequential m state -> m ()


-- data Command n m (state :: (* -> *) -> *) =
--   forall input output.
--   (HTraversable input, Show (input Symbolic), Typeable output) =>
--   Command {
--     -- | A generator which provides random arguments for a command. If the
--     --   command cannot be executed in the current state, it should return
--     --   'Nothing'.
--     --
--       commandGen ::
--         state Symbolic -> Maybe (n (input Symbolic))
--
--     -- | Executes a command using the arguments generated by 'commandGen'.
--     --
--     , commandExecute ::
--         input Concrete -> m output
--
--     -- | A set of callbacks which provide optional command configuration such
--     --   as pre-condtions, post-conditions and state updates.
--     --
--     , commandCallbacks ::
--         [Callback input output state]
--     }

newtype State a (v :: * -> *) = State { unState :: FocusList (Var a v) } deriving (Eq, Show)

initialState :: State a v
initialState = State emptyFL

data InsertFL a v = InsertFL !(FocusList (Var a v)) !Int !a deriving (Eq, Show)

instance HTraversable (InsertFL x) where
  htraverse :: forall f g h. Applicative f => (forall a. g a -> f (h a)) -> InsertFL x g -> f (InsertFL x h)
  htraverse func (InsertFL fl newKey newVal) = InsertFL <$> traverse go fl <*> pure newKey <*> pure newVal
    where
      go :: forall a. Var a g -> f (Var a h)
      go var = htraverse func var

insertFLCommand :: forall n m. (MonadGen n, MonadTest m) => Command n m (State String)
insertFLCommand =
  Command
    generator
    execute
    [ Update update
    , Ensure ensureInvariants
    , Ensure ensureStringInFL
    ]
  where
    generator :: State String Symbolic -> Maybe (n (InsertFL String Symbolic))
    generator (State fl) =
      Just $ do
        let len = fl ^. lensFocusListLen
        newKey <- int $ linear 0 len
        newVal <- string (linear 0 25) ascii
        pure (InsertFL fl newKey newVal)

    execute :: InsertFL String Concrete -> m String
    execute (InsertFL fl newKey newVal) =
      case insertFL newKey (Var (Concrete newVal)) fl of
        Nothing -> do
          annotate "Failed to insert a value into the FocusList"
          failure
        Just _ -> pure newVal

    update :: forall v. State String v -> InsertFL String v -> Var String v -> State String v
    update (State fl) (InsertFL _ newKey _) newVal =
      case insertFL newKey newVal fl of
        Nothing -> error "insertFLCommand, update: Failed to insert a value into the FocusList, even though we should be able to"
        Just newFL -> State newFL

    ensureInvariants :: State String Concrete -> State String Concrete -> InsertFL String Concrete -> String -> Test ()
    ensureInvariants _ (State endingFL) _ _ = assert (invariantFL endingFL)

    ensureStringInFL :: State String Concrete -> State String Concrete -> InsertFL String Concrete -> String -> Test ()
    ensureStringInFL _ (State endingFL) (InsertFL _ newKey newVal) _ =
      let maybeVal = lookupFL newKey endingFL
      in
      case maybeVal of
        Nothing -> do
          annotate "Couldn't find inserted value in FocusList"
          failure
        Just val -> val === Var (Concrete newVal)


-- data Callback input output state =
--   -- | A pre-condition for a command that must be verified before the command
--   --   can be executed. This is mainly used during shrinking to ensure that it
--   --   is still OK to run a command despite the fact that some previously
--   --   executed commands may have been removed from the sequence.
--   --
--     Require (state Symbolic -> input Symbolic -> Bool)

--   -- | Updates the model state, given the input and output of the command. Note
--   --   that this function is polymorphic in the type of values. This is because
--   --   it must work over 'Symbolic' values when we are generating actions, and
--   --   'Concrete' values when we are executing them.
--   --
--   | Update (forall v. Ord1 v => state v -> input v -> Var output v -> state v)

--   -- | A post-condition for a command that must be verified for the command to
--   --   be considered a success.
--   --
--   --   This callback receives the state prior to execution as the first
--   --   argument, and the state after execution as the second argument.
--   --
--   | Ensure (state Concrete -> state Concrete -> input Concrete -> output -> Test ())
