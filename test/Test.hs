
module Main where

import Termonad.Prelude

import Hedgehog
  ( Callback(Update)
  , Command(Command)
  , Concrete
  , HTraversable(htraverse)
  , MonadTest
  , Property
  , Symbolic
  , Var
  , annotate
  , executeSequential
  , failure
  , forAll
  , property
  )
import Hedgehog.Gen (sequential)
import Hedgehog.Range (linear)
import Test.Tasty (TestTree, defaultMain, testGroup)
import Test.Tasty.Hedgehog (testProperty)

import Termonad.FocusList (FocusList, emptyFL, insertFL)

main :: IO ()
main = do
  tests <- testsIO
  defaultMain tests

testsIO :: IO TestTree
testsIO = do
  pure $
    testGroup
      "tests"
      [ testProperty "foo" foo
      ]

foo :: Property
foo =
  property $ do
    actions <-
      forAll $
        sequential
          (linear 1 100)
          initialState
          [ insertFLCommand ]
    executeSequential initialState actions

-- property :: HasCallStack => PropertyT IO () -> Property

-- forAll :: (Monad m, Show a) => Gen a -> PropertyT m a
-- sequential :: (MonadGen n, MonadTest m) => Range Int -> (forall v. state v) -> [Command n m state] -> n (Sequential m state)

-- executeSequential :: (MonadTest m, MonadCatch m) => (forall v. state v) -> Sequential m state -> m ()


-- data Command n m (state :: (* -> *) -> *) =
--   forall input output.
--   (HTraversable input, Show (input Symbolic), Typeable output) =>
--   Command {
--     -- | A generator which provides random arguments for a command. If the
--     --   command cannot be executed in the current state, it should return
--     --   'Nothing'.
--     --
--       commandGen ::
--         state Symbolic -> Maybe (n (input Symbolic))
--
--     -- | Executes a command using the arguments generated by 'commandGen'.
--     --
--     , commandExecute ::
--         input Concrete -> m output
--
--     -- | A set of callbacks which provide optional command configuration such
--     --   as pre-condtions, post-conditions and state updates.
--     --
--     , commandCallbacks ::
--         [Callback input output state]
--     }

data State a (v :: k) = State { unState :: Var (FocusList a) v } deriving (Eq, Show)

initialState :: State a v
initialState = State emptyFL

data InsertFL a v = InsertFL { unInsertFL :: FocusList a } deriving (Eq, Show)

instance HTraversable (InsertFL x) where
  htraverse :: forall f g h. Applicative f => (forall a. g a -> f (h a)) -> InsertFL x g -> f (InsertFL x h)
  htraverse func (InsertFL x) = pure (InsertFL x)

insertFLCommand :: forall n m. (Monad n, MonadTest m) => Command n m (State String)
insertFLCommand = Command generator execute [Update update]
  where
    generator :: State String Symbolic -> Maybe (n (InsertFL String Symbolic))
    generator (State fl) = Just $ pure (InsertFL fl)

    execute :: InsertFL String Concrete -> m (FocusList String)
    execute (InsertFL fl) =
      case insertFL 0 "hello" fl of
        Nothing -> do
          annotate "Failed to insert a value into the FocusList"
          failure
        Just newFL -> pure newFL

    update :: State String v -> InsertFL String v -> Var (FocusList String) v -> State String v
    update (State fl) _ Var = undefined


-- data Callback input output state =
--   -- | A pre-condition for a command that must be verified before the command
--   --   can be executed. This is mainly used during shrinking to ensure that it
--   --   is still OK to run a command despite the fact that some previously
--   --   executed commands may have been removed from the sequence.
--   --
--     Require (state Symbolic -> input Symbolic -> Bool)

--   -- | Updates the model state, given the input and output of the command. Note
--   --   that this function is polymorphic in the type of values. This is because
--   --   it must work over 'Symbolic' values when we are generating actions, and
--   --   'Concrete' values when we are executing them.
--   --
--   | Update (forall v. Ord1 v => state v -> input v -> Var output v -> state v)

--   -- | A post-condition for a command that must be verified for the command to
--   --   be considered a success.
--   --
--   --   This callback receives the state prior to execution as the first
--   --   argument, and the state after execution as the second argument.
--   --
--   | Ensure (state Concrete -> state Concrete -> input Concrete -> output -> Test ())
